

曾经见到过这样一道面试题：有100个台阶，腿短的小明每次只能向上走一步或者两步，请问小明一共有多少种方法爬上100道台阶？

我们来简单分析一下。首先，爬上第一个台阶显然只有一种方法，我们记为f(1)=1;爬上第二个台阶有两种方法，第一种方法先向上走一步，到达第一个台阶处，
然后再向上走一步，到达第二个台阶处。第二种方法是一次走两步，直接走到第二个台阶处，我们记为f(2) = 2；那么爬上第n个台阶呢？想要爬上第n个台阶，也有两种方法，要么先走到第n-1个台阶处，再向上走一步，要么先走到第n-2个台阶处，再向上走两步。我们可以记为f(n) = f(n-1) + f(n -2).那么整理一下就有



可以看出来，这个公式其实就是一个斐波那契数列。根据公式，我们很快可以写出代码来。

```
long long fun(int n)
{
    if (n == 1)
        return 1;
    else if(n == 2)
        return 2;
    else if( n > 2)
        return fun(n-1) + fun(n-2);
}
```
但是这段代码的运行效率是非常低的,当计算f(100)的时候，必须先计算f(99)和f(98),计算f(99)的时候又要计算f(98).这样造成了大量的重复计算.设想一下,如果我们可以把计算的中间结果(比如f(i))保存在一个数据结构中,当需要用到f(i)的时候,我们先去这个结构中查询f(i)是否已经计算过了,如果计算过了，直接用,如果没有,那么计算一次,并把结果存储起来.根据这个思路,我们可以写出代码。
```
long long calc(long long step[],int n);
long long step[101]={0};
long long calc(long long step[], int n)
{
    long long i;
    if(n <= 0)
        return 0;
    step[0]=1;
    step[1]=1;
    if (n >= 2 && step[n-1] > 0 && step[n-2] > 0) {
        step[n] = step[n-1] + step[n-2];
        return step[n];
    } else if(n >= 2) {
        for(i = 2; i <= n; i++)
            step[i] = step[i-1]+step[i-2];
    }
    return step[n];
}
```
这个版本减少了大量的重复计算，比第一个版本效率要高很多。但是这个版本同样存在问题,首先我们不知道用户输入的n的大小,而开的数组是一个定长数组,当用户输入的n超过了定长数组规模时,程序没有办法处理。第二个问题是这个版本可能会造成大量的空间浪费，因为我们只需要知道最终的f(n)的值是多少，存储的中间结果我们是不关心的，程序花了大量的内存来保存我们并不关心的结果。

这个程序还可以进一步优化，前面两种实现都是自顶向下的实现方式。这次我们转换思路，自下而上来实现。我们知道了f(1)、f(2)就可以求出f(3),知道f(2)、f(3)就可以知道f(4)....以此类推,一直向上计算，就可以得出最终需要的f(n).

```
long long fun(int n)
{
    if(n == 1)
        return 1;
    else if(n == 2)
        return 2;
    long long a = 1;
    long long b = 2;
    long long res = 0;
    n -= 2;
    while(n--) {
        res = a + b;
        b = res;
        a = b;
    }
    return res;
}
```
这种方法比起第二种方法，节省了大量的内存，同时效率也很高。关于求斐波那契数列的方法还有多种，大家可以继续研究一下。

人生路漫漫,也跟爬楼梯一样。让我们跟小明一样,踏踏实实一步一个脚印的往上爬吧！














