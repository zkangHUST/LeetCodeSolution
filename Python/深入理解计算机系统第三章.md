## 深入理解计算机系统第三章习题
### 3.1 假设下面的值存放在指明的内存地址和寄存器中
|地址|值|寄存器|	值|	
|---|---|---|---|
|0x100|0xFF|%rax|0x100|
|0x104	|0xAB|%rcx|	0x1|	
|0x108|	0x13|%rdx|	0x3|
|0x10C|	0x11|	
请填写下表，给出所示操作数的值

|	|操作数|值|寻址方式|
|---|---|---|---|
|1|	%rax|	0x100|	寄存器寻址|
|2|	0x104|	0xAB|	立即数寻址|
3|	$0x108|	0x108|	立即数|
4|	(%rax)|	0xFF|	寄存器间接寻址|
5|	4(%rax)|	0xAB|	
6|	9(%rax, %rdx)|	0x11	
7|	260(%rcx, %rdx)|	0x13	
8|	0xFC(,%rcx,4)|	0xFF	
9|	(%rax, %rdx, 4)|	0x11	

**解析：**

该题主要考察寻址方式。汇编语言当中，寻址方式有多种，但是可以总结为一个通用模式为：
```
Imm(rb, ri, s) --> M[Imm + R[rb] +R[ri] * s] 
```
其含义是：取Imm + R[rb] + R[ri] * s这个内存地址中的值比如上例中的
`(%rax,%rdx,4)` 表示的是内存地址为%rax + %rdx*4的内存地址的值，即为0x11.
另外注意区分

```
Imm  --> M[Imm] 表示Imm这个地址存储的值
$Imm --> Imm 表示Imm这个立即数
%rax -->R[rax]  表示rax寄存器中存储的值
(%rax) –->M[R[rax]] 表示将rax的值作为地址寻址得到的值
```
### 3.2 对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。
例如，mov可以被重写为movb、movw、movl、movq。

```
movq %eax, (%rsp)       //传四字节，将eax的值传入rsp地址中
movw (%eax), %dx        //传两字节
movb  $0xFF, %bl        //传单个字节
movq (%rdx), %rax       //传四字节
movw %dx, (%rax)        //传两个字节
```

**解析:**
```
movb 传字节，b表示byte
movw 传送字，w表示word,即2个字节
movl 传送双字，l表示long word，即4个byte
movq 传送4字   q表示8个byte
```
mov传送指令的源操作数指定的值是一个立即数,存储在寄存器或者内存当中.目的操作数指定一个位置,要么是一个寄存器,要么是一个内存地址.寄存器部分的大小必须与指令的最后一个字符指定的大小相匹配。

### 3.3 当我们用汇编器的时候，下面代码的每一行都会产生一个错误信息，解释每一行哪里出了错
```
movb $0xF, (%eax)    // eax是64位寄存器，不能使用movb传送，改为movq
movl %rax, (%rsp)    // rax是64位寄存器，不能用movl传送，改为movq
movw (%rax), 4(%rsp) // rsp是64位寄存器，不能用movw传送，两个操作数不能都是内存引用
movb %al,%sl        //没有名为sl的寄存器
movq %rax, $0x123   //立即数不能作为dst操作数
movl %eax, %rdx     //rdx是64位寄存器，不能使用movl传送
movb %si, 8(%rbp)   //si是16位，不能用movb，改为movw
```
### 3.4 假设变量sp和dp被声明为类型
```
src_t   *sp;
dest_t  *dp;
```
这里,src_t和dest_t是用typedef声明的数据类型.我们想使用适当的数据传送指令来实现下面的操作
```
*dp = (dest_t)*sp;
```
假设sp和dp分配存储在寄存器%rdi和%rsi中.对于表中的每个表项，给出实现指定数据传送的两条命令.其中第一条从内存中读数据,做适当的转化,并设置寄存器%rax的适当部分.然后第二条指令应该把%rax的适当部分写入内存.在这两种情况下，寄存器的部分可以是%rax,%eax,%ax或者%al,两者可以互不相同。
记住，当执行强制类型转换既涉及大小变化，又涉及C语言中符号变化时，操作应该先改变大小。
```
src_t               dest_t      指令
long                long        movq (%rdi), %rax
                                movq %rax, (%rsi)
char                int         movsbl (%rdi), %eax             
                                //s表示符号拓展，int是有符号的，因此用s,bl表示byte->四字节的拓展。
                                movl  %eax, (%rsi)
char                unsigned    movzbl (%rdi), %rax
                                //z表示零拓展，unsigned是无符号int,因此用零拓展，
                                mov %rax, (%rsi)
unsigned char       long        mov


```





